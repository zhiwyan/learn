## select和epoll

### select实现

- 把fd_set从用户空间拷贝到内核空间
- 遍历所有的fd，调用对应的poll方法，把当前进程挂到设备等待队列中。
- poll方法会返回读写操作是否就绪，然后修改fd_set的内容。
- 如果遍历完所有的fd，如果有已经就绪的fd，将所有fd的就绪状态复制到用户空间。
- 如果没有就绪的fd，急挂起进程等待唤醒或超时。

### select的问题

- 单个进程可监视的fd数量被限制。
- 对socket进行扫描是线性扫描，即采用轮询方法，效率低
  - 每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大
  - 同时每次调用select都需要在内核遍历传递进来所有的fd，这个开销在fd很多多时也很大
- 需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大



### epoll实现

epoll是基于事件驱动的I/O方式。

- 创建epoll对象。当进程调用epoll_create方法时，内核会创建一个eventpoll对象。
- 维护监视列表。可以用 epoll_ctl添加或者删除所要监听的socket。
- 当进程执行到epoll_wait时，内核会将进程放入到eventpoll的等待队列中，阻塞进程。
- 当socket接受到数据，中断程序一方面修改rdlist，另一方面唤醒eventpoll等待队列中的进程，进程再次进入运行状态，因为rdlist的存在，进程可以知道哪些socket发生了变化。

### epoll优点

- 与select相比，epoll分清了频繁调用和不频繁调用的操作。如：epoll_ctrl是不频繁调用，epoll_wait是频繁调用。

- 通过mmap将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址，使得这块物理内存对内核和对用户均可见，减少用户态和内核态之间的数据交换。内核可以直接看到epoll监听的句柄，效率高。
- 用红黑树存储epoll监听的socket
- 通过epoll_ctl将事件添加进来时，都会与相应的设备驱动程序建立回调关系，当相应的事件发生后，会调用这个回调函数（ep_poll_callback）,这个回调函数会吧这个事件添加到rdlist这个双向链表中。那么调用epoll_wait时，epoll_wait只需要检查rdlist是否为空。这里也需要将发生了的事件复制到用户态内存中。

### epoll的模式

- 水平触发（LT）。默认工作模式，当epoll_wait检测到某描述符就绪并通知到应用程序时，应用程序可以不立即处理该事件；下次调用epoll_wait时，会再次通知该事件。
- 边缘触发（ET）。ET模式只在状态由未就绪变为就绪时只通知一次。当epoll_wait检测到某描述符就绪并通知程序时，应用程序必须立即处理该事件。如果不处理，下次再调用epoll_wait时，不会再通知此事件。