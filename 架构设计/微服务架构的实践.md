## 微服务架构的实践

### 架构设计的几点思考

- 架构设计不能脱离业务
- 能够快速定位服务问题
- php? Java or golang？ golang
- 开源 or 自研？自研

### 当时考虑的一些设计原则

- 保持简单，第一法则
- 高可用
- 高并发
- 易扩展
- 弹性设计
- 封装微服务复杂度，业务开发友好
- 做一件事只提供一种方式



## go微服务框架实现

### 微服务重要组件

- 控制并发请求
- 简单高效
- 可配置，有默认值
- 有效防止突发恶意流量
- 第一道防护（WAF等除外）



## 限流

### 分布式限流

- 基于redis/lua
- 令牌桶
- 漏桶
- 广泛使用，短信、推送等



## 自适应分级降载

### 基于优先级进行分级降载保护

- CPU>90%开始拒绝低优先级请求

- CPU>95%开始拒绝高优先级请求
- K8S的HPA 80%触发
- http/rpc框架内建
- 基于滑动窗口，防止毛刺
- 有冷却时间，防止抖动
- 实践检验，配合K8S弹性伸缩
- 第三道防护



## 自适应熔断

### 路径级别的自适应熔断

- 自动触发，自动恢复
- http/rpc框架内建
- Google SRE算法
- 基于滑动窗口（10秒/40窗口）
- 支持自定义触发条件
- 支持自定义fallback
- 第二道防护

### 负载均衡基于服务发现

- 服务提供方注册上报
- 服务调用方watch发现
- 进行服务调用

### Round Robin

- 简单
- 要求后端性能均等
- 响应时间变化较大时，容易导致负载不平衡

### (batch)一致性分发

- 基于hash ring
- 便于基于实体增加进程内缓存
- 支持最小放量，预热
- 少量高热点请求容易导致后端负载不均衡

### Power of Two Choices (将实现)

- 当前请求数
- 处理时长，指数加权移动平均 参考自 Nginx & Envoy & Finagle

### 多重防护，保障高可用

- 限流、并发控制
- 自适应降载、K8S弹性伸缩
- 自适应熔断、负载均衡
- rpc call



## 超时

### 进程内超时控制

- Fail Fast，少做无用功
- 有默认值，业务开发无需关注
- 注意客户端协同

### 服务间超时控制

- Fail Fast，少做无用功
- 通过context自动传递
- 忽略服务间调用网络损耗（一般几ms），降低复杂度



## 重试

### 重试机制注意事项

- 指数退避
- 流量quota
- 超时相关性



## http请求自动解析校验

### 支持的特性

- Path, form, json
- default, optional, options, range

### 解析校验

- httpx.Parse(...)
- 参数错误自动返回400
- 配合goctl使用，效果更佳



## 缓存

### 缓存设计三要点

- 缓存穿透，不存在的数据
- 缓存击穿，热点key过期
- 缓存雪崩，大量缓存同时过期

### 解决方法

- 缓存穿透
  - 即使查不到，也自动缓存，短时间过期，1分钟
- 缓存击穿
  - 确保一个进程只拿一次数据，并共享结果
- 缓存雪崩
  - 针对缓存过期时间设置随机偏差，确保分散过期
- 缓存基于非主键的查询
  - 转换为主键做缓存
  - 获取复杂，查询->主键->缓存
  - 过期复杂，顺序重要
- 分布式缓存
  - 多虚拟节点一致性hash，避免升降级后过多cach miss
- 很难全做对，是不是？
  - goctl生成CURD和cache代码



