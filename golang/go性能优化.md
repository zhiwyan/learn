## go性能优化

### 网络IO

1. 连接优化
   - 大量的短连接使用连接池提供长连接替代
   - 对连接数的消耗速率有个预估，给出最优连接池配置
2. 数据优化
   - 对大数据传输使用压缩算法进行压缩，大小缩减到原数据大小的1/5以内
   - 优化数据结构，减少嵌套层级，精简字段大小，合理使用字段类型
3. 协议封装
   - 对tcp进行封装，规定header及body的长度，避免粘包
   - 协议封装复用内存资源和对象资源，根据流量预估，给出最优复用方案

### 内存利用率

1. 字符串处理优化

   - 由于string类型是不可变类型，但拼接会创建新的string。go中字符串拼接常见有如下几种方式：
     - string + 操作：导致多次对象的分配与值拷贝
     - fmt.Sprintf：会动态解析参数，效率也不好
     - strings.Join：内部是[]byte的append
     - bytes.Buffer：可以预先分配大小，减少对象分配与拷贝
   - 字符串拼接优先考虑bytes.Buffer
   - 减少[]byte和string的转换，统一使用[]byte处理
   - bytes.Buffer等通过预先分配足够大的内存，避免当Grow时动态申请内存，这样可以减少分配次数
   - 频繁操作大字符串，考虑使用sync.Pool对象池，进行内存复用，合理设置内存池新对象的内存空间

2. 对象优化

   - 避免频繁创建临时变量

   - 对象拷贝考虑使用指针引用，减少内存分配

   - 创建频繁的对象，考虑使用sync.Pool对象池，进行对象复用，优化对象结构，精简属性字段

   - 小对象合并成结构体一次分配，减少内存分配次数，如例：

     ```go
     for k, v := range m {
       k, v := k, v // copy for capturing by the goroutine
       go func(){
         	// using k & v
       }()
     }
     ```

     替换为：

     ```go
     for k, v := range m {
       x := struct {k, v string} {k, v} // copy for capturing by the goroutine
       go func(){
         	// using x.k & x.v
       }()
     }
     ```

3. 变量使用优化

   - 尽量使用局部变量
   - 多个局部变量合并一个大的结构体或数组，减少扫描对象的次数，一次回尽可能多的内存
   - 变量拷贝考虑使用指针引用，减少内存分配

4. slice和map使用优化

   - slice和map与数组不一样，不存在固定空间大小，可以根据增加元素来动态扩容。

   - slice初始会指定一个数组，当对slice进行append的操作时，当容量不够会自动扩容：

     ```go
     ints := []int{1, 2} 			// 扩容前 oldCap = 2
     ints = append(ints, 3,4,5) // newCap = ?  5?
     ```

     - 如果新的大小是当前大小的2倍以上，则容量增长为新的大小；
     - 如果不符合上面的情况，接下来判断长度len，如果旧的长度小于1024，按2倍增加；否则每次按当前容量1/4增长，直到增长的容量超过或等于新大小。

   - map的扩容比较复杂，每次扩容会增加到上次容量的2倍。它的结构体中有一个buckets和oldbuckets，用于实现增量扩容：

     - 正常情况下，直接使用buckets，oldbuckets为空；
     - 如果正在扩容，则oldbuckets不为空，buckets是oldbuckets的2倍

   - 初始化时预估大小指定容量

     ```go
     m := make(map[int]int, 100)
     s := make([]int, 0, 100)
     ```

5. 并发优化

   - goroutine尽量独立，无冲突执行；若goroutine间存在冲突，则可以采用分区来控制goroutine的并发个数，减少同一互斥对象冲突并发数；
     - 传统多线程编程时，当并发冲突在4~8线程时，性能可能出现拐点。
     - go中推荐是不要通过共享内存来通讯，go创建goroutine非常容易，当大量goroutine共享同一互斥对象时，也会在某一数量的goroutine时，性能出现拐点。
   - goroutine虽轻量，但对于高并发的轻量任务处理，频繁来创建goroutine来执行，执行效率并不会太高效，考虑使用gorutine池：
     - 过多的goroutine创建，会影响go runtime对goroutine调度，以及GC消耗；
     - 高并发时若出现调用异常阻塞积压，大量goroutine短时间积压可能导致程序崩溃。
   - 把涉及到同步调用的goroutine，隔离到可控的goroutine中，而不是直接高并发的goroutine调用
     - goroutine的实现，是通过同步来模拟异步操作。在如下操作不会阻塞os线程：
       - 网络io
       - 锁
       - channel
       - time.sleep
       - 基于底层系统异步调用的Syscall
     - 下面操作会阻塞os线程：
       - 本地io调用
       - 基于底层系统同步调用Syscall
       - cgo方式调用c语言动态库中的调用io或其他阻塞
     - 网络io可以基于epoll的异步机制（或kqueue等异步机制），对于一些系统函数并没有提供异步机制。例如常见的posix api中，对文件的操作就是同步操作。虽然有开源的fileepoll来模拟异步文件操作。但go的syscall还是依赖底层的操作系统的api。系统api没有异步，go也做不了异步化处理。

6. 调用优化

   - 长调用栈避免申请过多的临时对象
     - goroutine的调用栈默认大小是4k（1.7修改为2k），它采用连续栈机制，当栈空间不够时，go runtime会扩容：
       - 当栈空间不够时，按2倍增加，原有栈的变量会直接copy到新的栈空间，变量指针指向新的空间地址；
       - 退栈会释放栈空间的占用，gc时发现栈空间占用不到1/4时，则栈空间减少一半。
     - 比如栈的最终大小2m，则极端情况下，就会有10次的扩栈操作，这会带来性能下降。
     - 建议：
       - 控制调用栈和函数的复杂度，不要在一个goroutine做完所有逻辑；
       - 如果的确需要长调用栈，则考虑goroutine池化，避免频繁创建goroutine带来的栈空间变化。
   - 避免使用cgo或者减少cgo调用次数
     - go可以调用c库函数，但go带有垃圾收集器且go的栈动态增长，但这些无法与c无缝对接。
     - go的环境转入c代码执行前，必须为c创建一个新的调用栈，把栈变量赋值给c调用栈，调用结束在拷贝回来。
     - 而这个调用的的开销非常大，需要维护go与c的调用上下文，两者调用栈的映射。相比直接的go调用栈，单纯的调用栈可能有2个甚至3个数量级以上。

