## goroutine原理及GPM调度模型

### GPM架构图

![gpm架构图](/Users/zwy/Documents/learn/uploads/MPG.png)

### 并发模型

并发模型分为内核线程模型、用户线程模型、两级线程模型

- 内核线程模型是用户线程和内核线程一对一映射模型。内核线程模型相对简单，一个用户线程绑定到一个内核线程上，线程调度由系统实现，实现了真正意义上的并发，但在不同线程做切换需要用户态到内核态切换，资源消耗较大，对性能影响很大。
- 用户线程模型是内核线程和用户线程一对多映射模型。多个用户线程绑定到一个内核线程上，线程调度由用户线程库实现，系统对用户线程无感知，该模型线程调度由于不需要用户态到内核态切换，实现起来比较轻量，资源消耗少，但该模型中所有线程都绑定到同一内核线程上，并没有实现真正的并发。
- 两级线程模型是内核线程和用户线程m对n（多对多）映射模型。该模型中n个用户线程和m个内核线程实现动态绑定，实现了系统级和用户级的两级调度模型，系统调度器调度内核线程，用户调度器调度用户级线，保证每个用户级线程公平调度，该模型实现了内核线程池的效果，可以大大减少内核线程创建、销毁的资源消耗和性能损失。

### G-P-M模型

- goroutine实现了两级线程模型，每一个go关键字都创建一个用户级线程，每一个被创建的线程都是一个可调度的执行单元。内核线程创建需要2m的固定栈空间，而每一个go线程只需要2k的栈空间，随着任务的执行，栈空间不足时，调度器会动态的给go线程分配另一块连续栈空间。内核线程的调度需要用户态到内核态的切换，非常消耗资源，而go线程调度由runtime在用户级别实现，资源消耗很少。
- goroutine模型，抽象为三个结构G、P、M，G代表一个用户级别的线程，G保存任务执行相关的堆栈和上下文状态。P代表一个逻辑处理器，每个P上都有一个G执行队列，P的数量决定了系统最大并行度，P的存在达到了内核线程池的效果。M代表一个系统线程，每个M在绑定一个P后开始执行上面的G，M不保存G的状态，这是G可以跨M调度的基础。

### G-P-M调度

goroutine队列分为global任务队列和P维护的local任务队列。当通过go关键字创建一个新的goroutine的时候，它会优先被放入P的本地队列。为了运行goroutine，M需要持有（绑定）一个P，接着M会启动一个os线程，循环从P的本地队列里取出一个goroutine并执行。当然还有上下文提及的 work-stealing调度算法：当M执行完了当前P的local队列里的所有G后，P也不会什么都不干，它会先尝试从global队列中寻找G来执行，如果global队列为空，它会随机挑选另外一个P，从它的队列中拿走一半的G到自己队列中执行。

1. 用户态阻塞处理

   goroutine因为channel或者锁同步阻塞时，该goroutine会被放到某个wait队列，该G的状态由runing变为waiting，而M会跳过该G尝试执行下一个G。

2. 内核态阻塞处理

   当G被阻塞在某个系统调用上时，此时G会阻塞在syscall状态，M也处于block on syscall状态，此时执行该G的M会与P解绑，而p则尝试与其他idle的M绑定，继续执行G。如果没有其他idle的M，但P中local队列中仍然有G需要执行，则创建一个新的M;当系统调用完成后，G会重新尝试获取一个idle的P进入它的local队列恢复执行，如果没有idle的P，G会被标记为runnable加入到global队列。

